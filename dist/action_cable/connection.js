"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const INTERNAL=require("./internal").default,ConnectionMonitor=require("./connection_monitor").default,{message_types:message_types,protocols:protocols}=INTERNAL,[supportedProtocols,unsupportedProtocol]=protocols.slice(0,-1).concat([protocols[protocols.length-1]]);class Connection{constructor(t,e,o){this.disconnected=!0,this.send=t=>!!this.isOpen()&&(this.webSocket.send(JSON.stringify(t)),!0),this.open=()=>this.isActive()?(this.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`),!1):(this.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${protocols}`),this.webSocket&&this.uninstallEventHandlers(),this.webSocket=new this.WebSocket(this.consumer.url,protocols,{headers:this.consumer.headers}),this.installEventHandlers(),this.monitor.start(),!0),this.close=({allowReconnect:t=!0}={})=>{t||this.monitor.stop(),this.webSocket&&this.isActive()&&this.webSocket.close()},this.reopen=()=>{if(this.log(`Reopening WebSocket, current state is ${this.getState()}`),this.isActive())try{this.close()}catch(t){this.log("Failed to reopen WebSocket",t)}finally{this.log(`Reopening WebSocket in ${Connection.reopenDelay}ms`),setTimeout(this.open,Connection.reopenDelay)}else this.open()},this.getProtocol=()=>{var t;return null===(t=this.webSocket)||void 0===t?void 0:t.protocol},this.isOpen=()=>this.isState("open"),this.isActive=()=>this.isState("open","connecting"),this.isProtocolSupported=()=>supportedProtocols.includes(this.getProtocol()),this.isState=(...t)=>t.includes(this.getState()),this.getState=()=>{var t;if(null!=(null===(t=this.webSocket)||void 0===t?void 0:t.readyState))for(const[t,e]of Object.entries(globalThis.WebSocket||{}))if(e===this.webSocket.readyState)return t.toLowerCase();return null},this.installEventHandlers=()=>{for(const t of Object.keys(this.events)){const e=this.events[t].bind(this);this.webSocket[`on${t}`]=e}},this.uninstallEventHandlers=()=>{for(const t of Object.keys(this.events))this.webSocket[`on${t}`]=()=>{}},this.events={message:t=>{if(!this.isProtocolSupported())return void(t.data.close&&t.data.close());const{identifier:e,message:o,type:s}=JSON.parse(t.data);switch(t.data.close&&t.data.close(),s){case message_types.welcome:this.monitor.recordConnect(),this.subscriptions.reload();break;case message_types.ping:this.monitor.recordPing();break;case message_types.confirmation:this.subscriptions.notify(e,"connected");break;case message_types.rejection:this.subscriptions.reject(e);break;default:this.subscriptions.notify(e,"received",o)}},open:()=>{this.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`),this.disconnected=!1,this.isProtocolSupported()||(this.log("Protocol is unsupported. Stopping monitor and disconnecting."),this.close({allowReconnect:!1}))},close:t=>{this.log("WebSocket onclose event"),this.disconnected||(this.disconnected=!0,this.monitor.recordDisconnect(),this.subscriptions.notifyAll("disconnected",{willAttemptReconnect:this.monitor.isRunning()}))},error:t=>{this.log("WebSocket onerror event"),this.subscriptions.notifyAll("error",t)}},this.consumer=t,this.log=e,this.WebSocket=o,this.subscriptions=t.subscriptions,this.monitor=new ConnectionMonitor(this,e)}}Connection.reopenDelay=500,exports.default=Connection;